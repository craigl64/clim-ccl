;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; Package: CLIM-INTERNALS; Base: 10; Lowercase: Yes -*-


(in-package :clim-internals)

"Copyright (c) 1990, 1991, 1992 Symbolics, Inc.  All rights reserved."

;;; This does not conform to the conventions described under Appendix C:
;;; Structuring Conventions of the PostScript Language Reference Manual.
;;; Part of the reason for non-conformance is the maybe-send-feature
;;; hack.  Were it possible for this implementation to send more than
;;; one page to the printer, then the stuff downloaded using the
;;; maybe-send-feature hack would be associated with a single page
;;; rather than with the whole document and reordering of the pages by
;;; some other tool could cause features which were first generated by
;;; one page and later referenced by another to become undefined if
;;; those pages were reordered.  The %% comments do conform except for
;;; %%Page and the feature reordering problem.

;;; Line thickness currently uses "1 setlinewidth" for minimum line
;;; thickness.  This can produce a line 2 pixels wide since there can be
;;; 2 pixels that are less than or equal to 1/2 away from the line.  "0
;;; setlinewidth" means to use the minimum for the resolution of the
;;; device.  At least now, for the case of line thickness of 1 :normal, this
;;; will use 0 setlinewidth for output to the Apple Laser Writer.

(defparameter *ps-magic-baseline-factor* 0.2)	;estimation of % baseline to bottom.

(defparameter *1-pixel=points* 1.2)		;1 "average" pixel is about 1.2 points

(defmacro round-up (x)
  `(floor (+ ,x 0.5)))

;;--- Convert CLIM units ("pixels") to (printers') points
(defmacro pixels-to-points (&rest pixels)
  (let ((forms nil))
    (dolist (pixel pixels)
      (push `(setq ,pixel (* ,pixel *1-pixel=points*)) forms))
    `(progn ,@(nreverse forms))))

;;--- Convert (printers') points to CLIM units ("pixels")
(defmacro points-to-pixels (&rest points)
  (let ((forms nil))
    (dolist (point points)
      (push `(setq ,point (round-up (/ ,point *1-pixel=points*))) forms))
    `(progn ,@(nreverse forms))))

(defvar *annotate-postscript* nil)

(defmacro annotating-postscript ((stream printer-stream) &body body)
  `(when *annotate-postscript*
     (let* ((,printer-stream (slot-value ,stream 'printer-stream))
	    (text (with-output-to-string (,printer-stream) ,@body))
	    (start 0))
       (loop
	 (let ((newline (position #\newline text :start start)))
	   (write-string "% " ,printer-stream)
	   (write-string text ,printer-stream :start start :end newline)
	   (unless newline (return))
	   (setq start (1+ newline))))
       (fresh-line ,printer-stream))))


;;; How the font hackery works:

;;; For each CLIM text style used in the output, a corresponding scaled
;;; font must exist in the PostScript engine.  (The PostScript books
;;; recommend that for efficiency you cache the results of operations
;;; like scalefont).  There is one PS-FONT-COMPAT-KLUDGE structure
;;; created for each CLIM text style used.  These structures are stored
;;; in the FONT-MAP slot of POSTSCRIPT-IMPLEMENTATION-MIXIN streams.
;;; Inside the PostScript engine there is a corresponding array named
;;; fontarray, whose i'th element contains the scaled postscript font
;;; object described by the i'th element of FONT-MAP.

;;; The function GET-FONT-COMPAT-STR is used to find the
;;; PS-FONT-COMPAT-KLUDGE object corresponding to a CLIM text style.
;;; The first time a CLIM text style is encounterred,
;;; GET-FONT-COMPAT-STR creates a PS-FONT-COMPAT-KLUDGE object for it,
;;; stores it in FONT-MAP and generates postscript code to construct the
;;; corresponding scaled postscript font and store it in fontarray
;;; using the postscript estfont procedure defined in the preamble.

;;; CONVERT-CLIM-TO-PS-FONT-DESCRIPTION converts a CLIM text style, eg.
;;; (:serif :bold :large) to a postscript font description, eg. ("Times"
;;; :bold 12).   When estfont is used, it interns a font "Times-Bold" of
;;; size 12 as the appropriate element of fontarray.

;;; This structure is used to represent a PostScript font masquerading as a
;;; CLIM-world entity.  They populate the font-map array of the stream.
(defstruct (ps-font-compat-kludge (:conc-name psfck-))
  index					;index into stream's array.
  style-descriptor			;parse-text-style output.
  true-ps-descriptor			;("Times" :italic 6 [pts])
  points				;point-size
  clim-height				;equivalent size in CLIM "pixels"
  clim-ascent				;top-to-baseline, "pixels"
  clim-descent				;baseline-to-bottom
  width-table				;width array or constant #.
  (established nil))			;T ==> written to the printer

;;; Each element is ((family face) width-or-width-table-array height ascent descent)
(defvar *char-width-tables* nil)

(defun make-new-fcs (text-style index)
  (let ((fcs (make-ps-font-compat-kludge
	       :index index
	       :style-descriptor text-style
	       :true-ps-descriptor (convert-clim-to-ps-font-description text-style))))
    (initialize-fcs fcs)
    fcs))

(defun initialize-fcs (fcs)
  (let* ((points (third (psfck-true-ps-descriptor fcs)))
	 (key `(,(first (psfck-true-ps-descriptor fcs))
		,(second (psfck-true-ps-descriptor fcs))))
	 (metrics (assoc key *char-width-tables* :test #'equal)))
    (unless metrics
      (error "No font metrics for ~S" key))
    (setf (psfck-points fcs) points)
    (let ((width-table (second metrics))
	  (height (third metrics))
	  (ascent (fourth metrics))
	  (descent (fifth metrics)))
      (setf (psfck-clim-height fcs) (* points height))
      (setf (psfck-clim-ascent fcs) (* points ascent))
      (setf (psfck-clim-descent fcs) (* points descent))
      (setf (psfck-width-table fcs) width-table)))
  nil)

;;; Each element is composed of:
;;;      - a CLIM text family keyword,
;;;      - the name of a font to use for that family,
;;;      - a list of point sizes corresponding to the text size keywords
;;;        in the corresponding positions in *psftd-keywords*.
;;; We should be able to phjase this out since we have a
;;; STANDARDIZE-STYLE method for postscript devices.
(defparameter *postscript-font-translate-data*
	     '((:fix "Courier" (4 6 7 9 11 14 18))
	       (:sans-serif "Helvetica" (5 7 8 10 12 16 20))
	       (:serif "Times" (5 7 8 10 12 16 20))))

(defparameter *psftd-keywords* '(:tiny :very-small :small :normal :large :very-large :huge))

;; The second element is a character size, which is either a number or a
;; place to go looking to get the character width table
(defparameter *ps-font-family-data*
	      '(("Times" 
		 (nil "tir" "Times-Roman")
		 (:bold "tib" "Times-Bold")
		 (:italic "tii" "Times-Italic")
		 (:bold-italic "tibi" "Times-BoldItalic"))
		("Helvetica"
		 (nil "he" "Helvetica")
		 (:bold "heb" "Helvetica-Bold")
		 (:italic "heo" "Helvetica-Oblique")
		 (:bold-italic "hebo" "Helvetica-BoldOblique"))
		("Courier"
		 (nil 0.6 "Courier")
		 (:bold 0.6 "Courier-Bold")
		 (:italic 0.6 "Courier-Oblique")
		 (:bold-italic 0.6 "Courier-BoldOblique"))))

(defun get-ps-fam-face-name (fcs)
  (let ((fam (first (psfck-true-ps-descriptor fcs)))
	(face (second (psfck-true-ps-descriptor fcs))))
    (let ((famdata (cdr (or (assoc fam *ps-font-family-data* :test #'string-equal)
			    (error "No info for PostScript font family ~A" fam)))))
      (third (or (assoc face famdata)
		 (error "No info for PostScript family ~A face ~A." fam face))))))
	
;; Value is a 3 element list acceptable as a returned value from
;; CONVERT-CLIM-TO-PS-FONT-DESCRIPTION:  a postscript family name as
;; appears in the CARs of the elements of *PS-FONT-FAMILY-DATA*, a face
;; keyword as returned by the function KEYWORDIFY-STYLE-FACE, and a
;; size in points.
(defparameter *ps-font-description-for-undefined-style* '("Courier" nil 4))	      

(defun convert-clim-to-ps-font-description (style)
  (let ((size (text-style-size style))
	(face (keywordify-style-face (text-style-face style)))
	(family (text-style-family style)))
    (if (and *ps-font-description-for-undefined-style*
	     (eq style *undefined-text-style*))
	;;--- Probably pointless to issue any sort of warning here
	*ps-font-description-for-undefined-style*
	(let* ((famdat (or (assoc family *postscript-font-translate-data*)
			   (error "Don't have PostScript support for family ~A." family)))
	       (points (if (numberp size)
			   size
			   (point-size-for-size-keyword size famdat)))
	       (psname (second famdat)))
	  `(,psname ,face ,points)))))

(defun keywordify-style-face (face)
  (cond ((eq face ':roman) nil)
	((atom face) face)
	((equal face '(:bold :italic)) :bold-italic)
	((equal face '(:italic :bold)) :bold-italic)
	(t (list :numeric-code face))))

(defun point-size-for-size-keyword (size-keyword family-data)
  (nth (or (position size-keyword *psftd-keywords*)
	   (error "Don't have PostScript support for size ~A." size-keyword))
       (third family-data)))

;;; This actually reads metrics for the Apple LaserWriter.  Some day we
;;; should make the font width table stuff device independent.
;;; The metrics are in sys:clim;laserwriter-metrics.lisp.newest.
;;; That file consists of invocations of this function.
;;; Don't bother loading the width information for fixed width fonts like Courrier
;;; which already have their width hard-coded in *ps-font-family-data*?
(defun setup-laserwriter-metrics (font-info)
  (let ((char-widths (cdr font-info))
	(name (caar font-info))
	(scale (cadar font-info))
	(box (caddar font-info))
	(width-table nil))
    (multiple-value-bind (family face size-kludge)
	(find-family-and-face-for-postscript-font-name name)
      ;; if the kludgy size element of the font's description in
      ;; *ps-font-family-data* is a number, just use it instead of
      ;; building the width table.
      (cond ((numberp size-kludge)
	     (setq width-table size-kludge))
	    (t
	     (setq width-table (make-array 256))
	     (dolist (char-info char-widths)
	       (let ((char-code (first char-info))
		     (char-width (/ (second char-info) scale)))
		 (setf (aref width-table char-code) char-width)))))
      (let ((key `(,family ,face)))
	(when (car key)				;check family to make sure we found the name
	  (let* ((temp (assoc key *char-width-tables* :test #'equal))
		 (height (abs (/ (- (fourth box) (second box)) scale)))
		 (ascent (abs (/ (fourth box) scale)))
		 (descent (abs (/ (second box) scale)))
		 (data `(,width-table ,height ,ascent ,descent)))
	    (if temp
		(setf (cdr temp) data)
		(push `(,key ,@data) *char-width-tables*))))))))

(defun find-family-and-face-for-postscript-font-name (name)
  (dolist (family-data *ps-font-family-data*)
    (let ((family (car family-data)))
      (dolist (face-data (cdr family-data))
	(let ((face (first face-data))
	      (size-kludge (second face-data))
	      (fname (third face-data)))
	  (when (string= name fname)
	    (return-from find-family-and-face-for-postscript-font-name
	      (values family face size-kludge))))))))


(defclass postscript-implementation-mixin ()
     ((printer-stream :initarg :stream)
      (current-color :initform nil)		;for decoding stippled inks
      (features-sent :initform nil)
      (curfont :initform nil)			;a psfck structure
      (ch1buf :initform (make-array 1 :element-type 'extended-char))	;used for char ops.
      (font-map :initform (make-array 30 :initial-element nil))
      (header-comments :initform nil :initarg :header-comments)
      (orientation :initform :portrait :initarg :orientation)
      ;; For multi-page output, analogous to a window's scroll position
      (multi-page :initform nil :initarg :multi-page)
      (viewport-x :initform 0)
      (viewport-y :initform 0)))

(defmethod implementation-pixels-per-point ((stream postscript-implementation-mixin))
  (/ *1-pixel=points*))

(defmethod stream-force-output ((stream postscript-implementation-mixin))
  (force-output (slot-value stream 'printer-stream)))

(defmethod stream-clear-output ((stream postscript-implementation-mixin))
  (clear-output (slot-value stream 'printer-stream)))

(defmethod stream-finish-output ((stream postscript-implementation-mixin))
  (finish-output (slot-value stream 'printer-stream)))

;;; Methods that might be needed:
;;; what about other "window" protocols?
;;; host-window-margins
;;; window-margins (being flushed, should return (values 0 0 0 0))
;;; window-beep
;;; window-clear (do a fresh-page?)

;;; Support routines

(defmacro making-ps-array ((printer-stream) &body body)
  `(progn (write-string " [ " ,printer-stream)
	  ,@body
	  (write-string " ] " ,printer-stream)))

(defmacro making-ps-hex-string ((printer-stream) &body body)
  `(progn (write-char #\< ,printer-stream)
	  ,@body
	  (write-char #\> ,printer-stream)))

(defmacro with-postscript-gsave (stream &body body)
  `(flet ((with-gsave-body () ,@body))
     (declare (dynamic-extent #'with-gsave-body))
     (invoke-with-postscript-gsave ,stream #'with-gsave-body)))

(defmethod invoke-with-postscript-gsave ((stream postscript-implementation-mixin) continuation)
  (with-slots (printer-stream) stream
    (format printer-stream " gsave~%")
    (funcall continuation)
    (format printer-stream " grestore~%")))

(defmethod maybe-send-feature ((stream postscript-implementation-mixin)
			       feature-name
			       code)
  (with-slots (features-sent printer-stream) stream
    (unless (member feature-name features-sent)
      (annotating-postscript (stream printer-stream)
	(format printer-stream "---------------- Feature ~A ----------------"
	  feature-name))
      (write-string code printer-stream)
      (annotating-postscript (stream printer-stream)
	(format printer-stream "---------------- End Feature ~A ----------------"
	  feature-name))
      (push feature-name features-sent))))

(defmethod ps-pos-op ((stream postscript-implementation-mixin) op x y &rest args)
  (declare (dynamic-extent args))
  (pixels-to-points x y)
  (with-slots (printer-stream display-device-type) stream
    (write-char #\space printer-stream)
    (ps-optimal-flonize
      (+ (* (slot-value display-device-type 'page-indent)
	    (slot-value display-device-type 'device-units-per-inch)) x)
      printer-stream)
    (write-char #\space printer-stream)
    (ps-optimal-flonize
      (- (* (slot-value display-device-type 'page-height)
	    (slot-value display-device-type 'device-units-per-inch)) y)
      printer-stream)
    (dolist (arg args)
      (write-char #\space printer-stream)
      (if (numberp arg)
	  (ps-optimal-flonize arg printer-stream)
	  (write arg :stream printer-stream :escape nil)))
    (format printer-stream " ~A" op)
    (if (string-equal op "m")
	(write-char #\space printer-stream)
	(terpri printer-stream))))

(defmethod ps-rel-pos-op ((stream postscript-implementation-mixin) op x y &rest args)
  (declare (dynamic-extent args))
  (pixels-to-points x y)
  (with-slots (printer-stream) stream
    (write-char #\space printer-stream)
    (ps-optimal-flonize x printer-stream)
    (write-char #\space printer-stream)
    (ps-optimal-flonize (- y) printer-stream)
    (dolist (arg args)
      (write-char #\space printer-stream)
      (if (numberp arg)
	  (ps-optimal-flonize arg printer-stream)
	  (write arg :stream printer-stream :escape nil)))
    (format printer-stream " ~A~%" op)))

;;; the software that drives the LGP2 (sys:hardcopy;postscript.lisp)
;;; uses LGP:FAST-PRINT-NUM except for writing transformation matrices,
;;; for which it uses 
;;;       (prin1 (if (fixp elem) elem (float elem)) output-stream)
;;; and also some cases of Format ~D.
(defun ps-optimal-flonize (n stream)
  ;; lifted from definition of LGP:FAST-PRINT-NUM in "Q:>sys>hardcopy>postscript.lisp.1679"
  (if (and (not (zerop n))
	   (< -1 n 1))
      (format stream "~F" (float n))
      (multiple-value-bind (integer frac)
	  (etypecase n
	    (integer (values (abs n) 0))
	    (float (truncate (round (* (abs n) 100.)) 100))
	    (rational (truncate (round (* (abs n) 100.)) 100)))
	(if (>= integer 10000.)
	    (if (integerp n)
		(write n :stream stream :escape nil :base 10 :radix nil)
		(format stream "~$" n))
	    (let ((from 8)
		  (negative-p nil))
	      (when (minusp n)
		(setq negative-p t))
	      (with-stack-array (string from :element-type 'extended-char)
		(macrolet ((add-char (char)
			     `(setf (aref string (decf from)) ,char)))
		  (when (/= frac 0)
		    (multiple-value-bind (frac1 frac2)
			(truncate frac 10.)
		      (when (/= frac2 0)
			(add-char (code-char (+ (char-code #\0) frac2))))
		      (add-char (code-char (+ (char-code #\0) frac1))))
		    (add-char #\.))
		  (let ((digit 0))
		    (loop
		      (multiple-value-setq (integer digit)
			(truncate integer 10.))
		      (add-char (code-char (+ (char-code #\0) digit)))
		      (when (zerop integer) (return))))
		  (when negative-p (add-char #\-))
		  (write-string string stream :start from)
		  n)))))))

(defun use-line-style (stream line-style)
  (let ((thickness (case (line-style-unit line-style)
		     (:normal (normal-line-thickness (stream-display-device-type stream)
						     (line-style-thickness line-style)))
		     (:points (line-style-thickness line-style))))
	(dashes (line-style-dashes line-style)))
    (with-slots (printer-stream) stream
      (format printer-stream " ~D setlinewidth~%" thickness)
      (when dashes
	(making-ps-array (printer-stream)
	  (let ((limit (length dashes)))
	    (dotimes (i limit)
	      (write (elt dashes i) :stream printer-stream :escape nil)
	      (unless (>= (1+ i) limit)
		(write-char #\space printer-stream)))))
	(format printer-stream "0 setdash~%")))))

(defun color-equal (c1 c2)
  (or (eq c1 c2)
      (and (colorp c1)
	   (colorp c2)
	   (multiple-value-bind (r1 g1 b1) (color-rgb c1)
	     (multiple-value-bind (r2 g2 b2) (color-rgb c2)
	       (and (= r1 r2) (= g1 g2) (= b1 b2)))))))

(defmethod maybe-set-color
	   ((stream postscript-implementation-mixin) (ink (eql +foreground-ink+)))
  (maybe-set-color stream (or (slot-value stream 'current-color) +black+)))

(defmethod maybe-set-color
	   ((stream postscript-implementation-mixin) (ink (eql +background-ink+)))
  (maybe-set-color stream +white+))

(defmethod maybe-set-color
	   ((stream postscript-implementation-mixin) (ink flipping-ink))
  (error "Postscript devices can't draw with flipping inks."))

(defmethod maybe-set-color ((stream postscript-implementation-mixin) (ink color))
  (with-slots (current-color printer-stream) stream
    (when (or (null current-color)
	      (not (color-equal current-color ink)))
      (setf current-color ink)
      (multiple-value-bind (r g b) (color-rgb ink)
	(format printer-stream  " ~,2F ~,2F ~,2F setrgbcolor~%" r g b)))))

(defmethod maybe-set-color ((stream postscript-implementation-mixin) (ink rectangular-tile))
  ;; Handled in the patterned fill/stroke case
  )

(defmethod maybe-set-color
	   ((stream postscript-implementation-mixin) (ink contrasting-ink))
  (maybe-set-color stream (make-color-for-contrasting-ink ink)))

;; "Not suitable for ritual use."
(defparameter *ps-ellipse-code*
"
/emtrx matrix def
/elpd 8 dict def
/ellipse {{arc} ellipsei} def
/ellipsen {{arcn} ellipsei} def
/ellipsei {elpd begin /arcp exch def /ea exch def /sa exch def /yra exch def /xra exch def
      /y exch def /x exch def
emtrx currentmatrix
x y translate xra yra scale 0 0 1 sa ea arcp setmatrix end} def
")

(defparameter *pattern-code*
        ;; for drawing filled patterns
        "/imgdict 12 dict def
%draw image.  One source pixel to one user space unit.
%width width-rounded-up height
/img { imgdict begin
        [/height /bitwidth /width ] {exch def} forall
        /nbits bitwidth height mul def
        /str 100 string def
        nbits 0 ne {
          gsave width height scale
          bitwidth height true [bitwidth 0 0 height neg 0 height] 
            {   nbits 800 ge {/nbits nbits 800 sub def str} 
                               {nbits 8 idiv string /nbits 0 def}
                            ifelse 
                  currentfile exch readhexstring pop}
          imagemask grestore
        } if end
        } def
/fmod { 2 copy div floor mul sub } bind def
%draw patterned rectangle.  One source pixel to scale device units (ignoring user scale).
%width height pattern scale
/pat { imgdict begin gsave
        [/scal /patseq ] {exch def} forall
        /patheight patseq length def
        /patwidth patseq 0 get length 8 mul def
%back up to an even phase boundary
        /pswidth patwidth scal mul def
        /psheight patheight scal mul def
        pswidth psheight idtransform
        0 0 transform psheight fmod neg exch pswidth fmod neg exch idtransform
        3 -1 roll exch dup 0 gt {add} {exch pop} ifelse
        3 1 roll dup 0 gt {add} {exch pop} ifelse exch 2 copy translate
        3 -1 roll exch abs add 3 1 roll abs add exch dtransform
        psheight div abs ceiling cvi patheight mul /height exch def
        pswidth div abs ceiling cvi patwidth mul /width exch def
        width 0 ne { height 0 ne {
        /scanline -1 def /linebits 0 def
        width height idtransform abs scale scal dup scale
        width height true [width 0 0 height neg 0 height] 
        { linebits 0 le { /linebits width def
                          /scanline scanline 1 add patheight mod def
                          /linepat patseq scanline get def
                        } if
        /linebits linebits patwidth sub def linepat }
        imagemask } if } if grestore end
      } def
%draw pattern in all of visible area.
%pattern scale opaque-p
/patfill1 { initmatrix clippath
%condition-case for nocurrentpoint, returning empty rectangle
             errordict begin
               /nocurrentpoint dup dup load exch { pop 0 0 0 0 } def 
                 pathbbox
               6 -2 roll def end
             4 2 roll 2 copy translate 4 -2 roll
             3 -1 roll sub 3 1 roll exch sub exch
             3 -1 roll { 2 copy gsave 1 setgray newpath
                         0 0 moveto 0 exch lineto 0 rlineto currentpoint pop 0 lineto
                         closepath fill grestore } if
             4 -2 roll pat } def
%like fill, etc. but with pattern, scale and opaque-p options.
/patfill { gsave clip patfill1 grestore newpath } def
/pateofill { gsave eoclip patfill1 grestore newpath } def
/patstroke { gsave strokepath clip patfill1 grestore newpath } def
 ")

(defvar *postscript-prologue*
        "statusdict /waittimeout 30 put
/fontarray 30 array def
/f {fontarray exch get setfont} def
/estfont {findfont exch scalefont fontarray 3 1 roll put} def
/m {moveto} def
")

(defmethod postscript-prologue ((stream postscript-implementation-mixin))
  (with-slots (printer-stream header-comments display-device-type orientation) stream
    (format printer-stream "%!PS-Adobe-2.0 EPSF-2.0~%")
    (multiple-value-bind (left top right bottom)
	(postscript-bounding-box-edges stream)
      (format printer-stream "%%BoundingBox: ~D ~D ~D ~D~%"
	left top right bottom))
    (format printer-stream "%%Creator: CLIM 2.0~%")
    (let ((title (getf header-comments :title)))
      (when title
        (format printer-stream "%%Title: ~A~%" title)))
    (let ((for (or (getf header-comments :for) #+Genera zl:user-id)))
      (when for
        (format printer-stream "%%For: ~A~%" for)))
    (multiple-value-bind (second minute hour date month year)
	(decode-universal-time (get-universal-time))
      (format printer-stream "%%CreationDate: ~D-~A-~D ~2,'0D:~2,'0D:~2,'0D~%"
	date (svref #("Jan" "Feb" "Mar" "Apr" "May" "Jun"
		      "Jul" "Aug" "Sep" "Oct" "Nov" "Dec") month) year
	hour minute second))
    (format printer-stream "%%DocumentFonts: (atend)~%")
    (format printer-stream "%%EndComments~%")
    (write-string *postscript-prologue* printer-stream)
    (ecase orientation
      (:portrait
        (format printer-stream
            "/format-rotation 0 def ~%/format-y-translation 0 def~%"))
      (:landscape
        (format printer-stream
            "/format-rotation -90 def ~%/format-y-translation ~D def~%" 
          (* (slot-value display-device-type 'page-width)
             (slot-value display-device-type 'device-units-per-inch)))))
    (format printer-stream
        "/new-matrix {0 format-y-translation translate
		      format-rotation rotate} def
	 /new-page {showpage new-matrix} def~%")
    (postscript-device-prologue display-device-type printer-stream)
    (format printer-stream "%%EndProlog~%")
    (format printer-stream "~%new-matrix~%")))

(defmethod postscript-epilogue ((stream postscript-implementation-mixin))
  (with-slots (printer-stream display-device-type font-map) stream
    (format printer-stream "showpage~%")
    (postscript-device-epilogue display-device-type printer-stream)
    (format printer-stream "%%Trailer~%")
    (let ((font-names-used nil))
      (dotimes (index (length font-map))
        (let ((fcs (aref font-map index)))
          (when fcs
            (pushnew (get-ps-fam-face-name fcs) font-names-used :test #'string-equal))))
      (format printer-stream "%%DocumentFonts:~{~^ ~A~}~%" (nreverse font-names-used)))))

(defun send-pattern (stream printer-stream pattern)
  (maybe-send-feature stream 'pattern-program *pattern-code*)
  (making-ps-array (printer-stream)
    (let ((height (array-dimension pattern 0))
	  (width (array-dimension pattern 1)))
      (dotimes (j height)
	(making-ps-hex-string (printer-stream)
	  (send-raster printer-stream pattern 0 j width (1+ j) nil)))))
  (terpri printer-stream)
  (write-string " 4 true " printer-stream))

(defun send-raster (printer-stream raster left top right bottom &optional (terpri t))
  (assert (= bottom (1+ top)))
  (unless (zerop (rem right 8))
    (error "Sorry, can't hack right /= 0 (mod 8); you have ~D" right))
  (with-stack-array (arr (array-total-size raster) :element-type '(unsigned-byte 8)
						   :displaced-to raster)
    (with-temporary-string (buf :length 100)
      (let ((bytes-per-row (truncate (array-dimension raster 1) 8))
	    (bytes-per-raster (ceiling (- right left) 8)))
	(let ((toprow (* top bytes-per-row))
	      (botrow (* bottom bytes-per-row))
	      (bigend-digit-char "084c2a6e195d3b7f")
	      (j 0)
	      #+Genera (buf buf)
	      #+Genera (arr arr))
	  #+Genera (declare (sys:array-register bigend-digit-char buf arr))
	  (flet ((force-buf ()
		   (setf (fill-pointer buf) j)
		   (with-temporary-substring (subbuf buf 0 j)
		     (write-string subbuf printer-stream)
		     (when terpri
		       (terpri printer-stream)))))
	    (do* ((index (- botrow bytes-per-row) (- index bytes-per-row))
		  (i index index))
		 ((< index toprow))
	      (dotimes (n bytes-per-raster)
		#-(or Allegro Minima) (declare (ignore n))
		(let ((byte (aref arr i)))
		  (setf (aref buf j) 
			(aref bigend-digit-char (ldb (byte 4 0) byte)))
		  (setf (aref buf (1+ j))
			(aref bigend-digit-char (ldb (byte 4 4) byte)))
		  (incf i)
		  (incf j 2)
		  (when (> j 80) (force-buf)))))
	    (when (> j 0) (force-buf))))))))

(defun ps-fill (stream printer-stream ink)
  (cond ((typep ink 'rectangular-tile)
	 ;;--- Kludgy way to determine whether to use patterned drawing
	 (multiple-value-bind (array width height)
	     (decode-tile-as-stipple ink)
	   (declare (ignore width height))
	   (unless array
	     (error "Rectangular tiles other than stipples are not supported yet."))
	   (send-pattern stream printer-stream array)
	   (format printer-stream " patfill~%")))
	(t
	 (format printer-stream " fill~%"))))

(defun ps-stroke (stream printer-stream ink)
  (cond ((typep ink 'rectangular-tile)
	 ;;--- Kludgy way to determine whether to use patterned drawing
	 (multiple-value-bind (array width height)
	     (decode-tile-as-stipple ink)
	   (declare (ignore width height))
	   (unless array
	     (error "Rectangular tiles other than stipples are not supported yet."))
	   (send-pattern stream printer-stream array)
	   (format printer-stream " patstroke~%")))
	(t
	 (format printer-stream " stroke~%"))))
	
(defmacro with-postscript-drawing-options ((stream printer-stream-var
					    &key ink line-style epilogue (newpath T))
					   &body body)
  (let ((printer-stream (or printer-stream-var (make-symbol "printer-stream"))))
    `(let ((,printer-stream (slot-value ,stream 'printer-stream)))
       (when ,line-style
	 (use-line-style ,stream ,line-style))
       (maybe-set-color ,stream ,ink)
       ,@(when newpath `((format ,printer-stream " newpath~%")))
       ,@body
       ,@(case epilogue
	   (:default `((if (null ,line-style)
			   (ps-fill ,stream ,printer-stream ,ink)
			   (ps-stroke ,stream ,printer-stream ,ink))))
	   (:fill `((ps-fill ,stream ,printer-stream ,ink)))
	   (:stroke `((ps-stroke ,stream ,printer-stream ,ink)))))))

(defmethod draw-point-internal ((stream postscript-implementation-mixin) x-offset y-offset
				x y ink line-style)
  (translate-positions x-offset y-offset x y)
  (with-postscript-drawing-options (stream printer-stream
				    :epilogue :stroke
				    :ink ink :line-style line-style)
    (ps-pos-op stream "m" x y)
    (ps-rel-pos-op stream "rlineto" 0 0))
  (annotating-postscript (stream printer-stream)
    (format printer-stream "        (draw-point-internal ~D ~D ~D ~D ...)"
      x-offset y-offset x y)))

(defmethod draw-line-internal ((stream postscript-implementation-mixin) x-offset y-offset
			       start-x start-y end-x end-y ink line-style)
  (translate-positions x-offset y-offset start-x start-y end-x end-y)
  (with-postscript-drawing-options (stream printer-stream
				    :epilogue :stroke
				    :ink ink :line-style line-style)
    (ps-pos-op stream "m" start-x start-y)
    (ps-pos-op stream "lineto" end-x end-y))
  (annotating-postscript (stream printer-stream)
    (format printer-stream "        (draw-line-internal ~D ~D ~D ~D ~D ~D ...)"
      x-offset y-offset start-x start-y end-x end-y)))

(defmethod draw-rectangle-internal ((stream postscript-implementation-mixin) x-offset y-offset
				    left top right bottom ink line-style)
  (translate-positions x-offset y-offset left top right bottom)
  (with-postscript-drawing-options (stream printer-stream
				    :epilogue :default
				    :ink ink :line-style line-style)
    (ps-pos-op stream "m" left top)
    (ps-pos-op stream "lineto" right top)
    (ps-pos-op stream "lineto" right bottom)
    (ps-pos-op stream "lineto" left bottom)
    (format printer-stream " closepath "))	;no cr
  (annotating-postscript (stream printer-stream)
    (format printer-stream "        (draw-rectangle-internal ~D ~D ~D ~D ~D ~D ...)"
      x-offset y-offset left top right bottom)))

(defmethod draw-polygon-internal ((stream postscript-implementation-mixin) x-offset y-offset
				  list-of-x-and-ys closed ink line-style)
  (let ((points (translate-point-sequence x-offset y-offset list-of-x-and-ys)))
    (with-postscript-drawing-options (stream printer-stream
				      :epilogue :default
				      :ink ink :line-style line-style)
      (let ((start-x (first points))
	    (start-y (second points)))
	(ps-pos-op stream "m" start-x start-y)
	(do* ((points (cddr points) (cddr points))
	      (ex (first points) (first points))
	      (ey (second points) (second points)))
	     ((null points)
	      (when closed
		(format printer-stream " closepath ")))
	  (ps-pos-op stream "lineto" ex ey)))
      (annotating-postscript (stream printer-stream)
	(format printer-stream "        (draw-polygon-internal ~D ~D ~A ...)"
	  x-offset y-offset list-of-x-and-ys)))))

(defmethod draw-ellipse-internal ((stream postscript-implementation-mixin) x-offset y-offset
				  center-x center-y
				  radius-1-dx radius-1-dy radius-2-dx radius-2-dy
				  start-angle end-angle ink line-style)
  (maybe-send-feature stream 'ellipse *ps-ellipse-code*)
  (translate-positions x-offset y-offset center-x center-y)
  (when (null start-angle)
    (setq start-angle 0
	  end-angle 2pi))
  (when (< end-angle start-angle)
    (setq end-angle (+ end-angle 2pi)))
  (multiple-value-bind (x-radius y-radius)
      (cond ((and (= radius-1-dx 0) (= radius-2-dy 0))
	     (values (abs radius-2-dx) (abs radius-1-dy)))
	    ((and (= radius-2-dx 0) (= radius-1-dy 0))
	     (values (abs radius-1-dx) (abs radius-2-dy)))
	    (t (nyi)))
    (pixels-to-points x-radius y-radius)
    (flet ((skew-angle (a)
	     (atan (* (sin a) x-radius)
		   (* (cos a) y-radius))))
      (with-postscript-drawing-options (stream printer-stream
					:epilogue :default
					:ink ink :line-style line-style)
	(ps-pos-op stream "ellipse" center-x center-y
		   x-radius y-radius
		   ;; don't allow the common full-circle case to be
		   ;; screwed up by floating point error:
		   (if (zerop start-angle)
		       0
		       (radians->degrees (skew-angle start-angle)))
		   (if (= end-angle 2pi)
		       360
		       (radians->degrees (skew-angle end-angle)))))
      (annotating-postscript (stream printer-stream)
	(format printer-stream
	    "        (draw-ellipse-internal ~D ~D ~D ~D ~D ~D ~D ~D ~D ~D ...)"
	  x-offset y-offset
	  center-x center-y
	  radius-1-dx radius-1-dy
	  radius-2-dx radius-2-dy
	  start-angle end-angle)))))

;; These 2 clones of draw-string would be much more modular if there
;; were a reasonable way of passing arguments transparently, so that
;; we might be able to share code.
(defmethod draw-string-internal ((stream postscript-implementation-mixin) x-offset y-offset
				 string x y start end align-x align-y text-style ink)
  (unless end
    (setq end (length string)))
  (translate-positions x-offset y-offset x y)
  (let* ((fcs (get-font-compat-str stream text-style))
	 (height (round-up (psfck-clim-height fcs)))
	 (descent (round-up (psfck-clim-descent fcs)))
	 (ascent (- height descent)))
    (incf x (compute-text-x-adjustment
	      align-x stream string text-style start end))
    (incf y (compute-text-y-adjustment
	      align-y descent ascent height))
    ;; do raster/ink stuff.
    (set-font-if-needed stream fcs)
    (with-postscript-drawing-options (stream printer-stream
				      :epilogue nil :newpath nil
				      :ink ink)
      (ps-pos-op stream "m" x y)
      (carefully-output-ps-showstring printer-stream string start end))
    (annotating-postscript (stream printer-stream)
      (format printer-stream "      (draw-string-internal ~D ~D ~S ~D ~D ~D ~D ~S ~S ...)"
	x-offset y-offset string x y start end align-x align-y))))

(defmethod draw-character-internal ((stream postscript-implementation-mixin) x-offset y-offset
				    character x y align-x align-y text-style ink)
  (translate-positions x-offset y-offset x y)
  (with-slots (printer-stream ch1buf) stream
    (setf (aref ch1buf 0) character)
    (let* ((fcs (get-font-compat-str stream text-style))
	   (height (round-up (psfck-clim-height fcs)))
	   (descent (round-up (psfck-clim-descent fcs)))
	   (ascent (- height descent)))
      (incf x (compute-text-x-adjustment
		align-x stream character text-style))
      (incf y (compute-text-y-adjustment
		align-y descent ascent height))
      ;; do raster/ink stuff.
      (set-font-if-needed stream fcs)
      (with-postscript-drawing-options (stream printer-stream
					:epilogue nil :newpath nil
					:ink ink)
	(ps-pos-op stream "m" x y)
	(carefully-output-ps-showstring printer-stream ch1buf 0 1))
      (annotating-postscript (stream printer-stream)
	(format printer-stream "      (draw-character-internal ~D ~D ~C ~D ~D ~S ~S ...)"
	  x-offset y-offset character x y align-x align-y)))))

(defmethod draw-vertical-string-internal ((stream postscript-implementation-mixin)
					  x-offset y-offset
					  string x y start end
					  align-x align-y text-style ink)
  (unless end
    (setq end (length string)))
  (unless text-style
    (setq text-style (medium-merged-text-style stream)))
  (translate-positions x-offset y-offset x y)
  (let* ((fcs (get-font-compat-str stream text-style))
	 (height (round-up (psfck-clim-height fcs)))
	 (descent (round-up (psfck-clim-descent fcs)))
	 (ascent (- height descent)))
    (let ((x-adjust (compute-text-x-adjustment
		      align-x stream string text-style start end))
	  (y-adjust (compute-text-y-adjustment
		      align-y descent ascent height)))
      (set-font-if-needed stream fcs)
      (with-postscript-drawing-options (stream printer-stream
					:epilogue nil :newpath nil
					:ink ink)
	(with-postscript-gsave stream 
	  (ps-pos-op stream "m" x y)
	  (format printer-stream " currentpoint translate 90 rotate ")
	  (ps-rel-pos-op stream "rmoveto" x-adjust y-adjust)
	  (carefully-output-ps-showstring printer-stream string start end))))))

;;; provide a way for the "user" to start a new page.
;;; Should this have a different name?
;;; Should this functionality be invoked by wriuting the #\page character?
(defmethod new-page ((stream postscript-implementation-mixin))
  (with-slots (printer-stream orientation) stream
    (format printer-stream "new-page~%"))
  ;; simulate WINDOW-CLEAR:
  (clear-output-history stream)
  (when (extended-output-stream-p stream)	;can we assume this?
    (stream-set-cursor-position* stream 0 0)
    (setf (stream-baseline stream) 0
	  (stream-current-line-height stream) 0)))

(defmacro with-ps-stream-glyph-for-character (&body body)
  `(macrolet ((stream-glyph-for-character (stream character style &optional our-font)
		`(with-slots (display-device-type) ,stream
		   (multiple-value-bind (character-set index)
		       (char-character-set-and-index ,character)
		     (declare (ignore character-set))
		     ;; For now we are asserting that each string passed to WRITE-STRING will
		     ;; have no style changes within it.  This is what our-font is all
		     ;; about.
		     (let* ((fcs (or our-font (get-font-compat-str stream ,style)))
			    (CWT (psfck-width-table fcs))
			    (relwidth (if (numberp CWT) 
					  CWT
					  (aref CWT index)))
			    (escapement-x (round-up (* (psfck-clim-height fcs) relwidth)))
			    (escapement-y 0)
			    (origin-x 0)
			    (origin-y (round-up (psfck-clim-ascent fcs)))
			    ;; really ought know real dope, but not avl yet
			    (bb-x escapement-x)
			    (bb-y (round-up (psfck-clim-height fcs))))
		       (values index fcs escapement-x escapement-y origin-x origin-y
			       bb-x bb-y (numberp cwt)))))))
     ,@body))

(defmethod stream-glyph-for-character ((stream postscript-implementation-mixin)
				       character style &optional our-font)
  (declare (values index font escapement-x escapement-y origin-x origin-y bb-x bb-y
		   fixed-width-font-p))
  (with-ps-stream-glyph-for-character
    (stream-glyph-for-character stream character style our-font)))

(defmethod stream-scan-string-for-writing ((stream postscript-implementation-mixin) string
					   start end style cursor-x max-x
					   &optional glyph-buffer)
  (declare (type coordinate cursor-x max-x))
  (declare (fixnum start end))
  (with-ps-stream-glyph-for-character 
    (stream-scan-string-for-writing-body)))

(defmethod stream-write-string-1 ((stream postscript-implementation-mixin)
				  glyph-buffer start end font color x y)
  (when (<= end start) (return-from stream-write-string-1))
  (let* ((index start)
	 (index8 0)
	 (fcs font)
	 (ascent (round-up (psfck-clim-ascent fcs)))
	 #+Genera (glyph-buffer glyph-buffer))
    #+Genera (declare (sys:array-register glyph-buffer))
    (with-slots (printer-stream) stream
      (with-temporary-string (glyphs8 :length (- end start))
	#+Genera (declare (sys:array-register glyphs8))
	(setf (fill-pointer glyphs8) (- end start))
	(loop
	  (when (= index end) (return))
	  (setf (aref glyphs8 index8) (code-char (aref glyph-buffer index)))
	  (incf index)
	  (incf index8))
	(set-font-if-needed stream fcs)
	(maybe-set-color stream color)
	(ps-pos-op stream "m" x (+ y ascent))
	(carefully-output-ps-showstring printer-stream glyphs8 0 (- end start))))))

;;--- It's really marginal that characters don't get buffered into a
;;--- string to be sent all at once.  
(defmethod stream-write-char-1 ((stream postscript-implementation-mixin) index font color x y)
  (let* ((c (code-char index))
	 (fcs font)
	 (ascent (round-up (psfck-clim-ascent fcs))))
    (with-slots (printer-stream ch1buf) stream
      (setf (aref ch1buf 0) c)
      (set-font-if-needed stream fcs)
      (maybe-set-color stream color)
      (ps-pos-op stream "m" x (+ y ascent))
      (carefully-output-ps-showstring printer-stream ch1buf 0 1))))

(defmethod set-font-if-needed ((stream postscript-implementation-mixin) fcs)
  (with-slots (printer-stream curfont) stream
    (unless (eq curfont fcs)
      (format printer-stream "~D f " (psfck-index fcs))
      (setf curfont fcs))))

(defun carefully-output-ps-showstring (printer-stream data start end)
  (assert (<= end (length data)))
  (write-char #\( printer-stream)
  (loop
    (let ((next-special (position-if #'(lambda (char)
					 (or (eql char #\( )
					     (eql char #\) )
					     (eql char #\\ )))
				     data :start start :end end)))
      (write-string data printer-stream :start start :end (or next-special end))
      (when next-special
	(write-char #\\ printer-stream)
	(write-char (elt data next-special) printer-stream))
      (unless next-special (return))
      (setq start (1+ next-special))))
  (format printer-stream ") show~%"))

(defmethod get-font-compat-str ((stream postscript-implementation-mixin) text-style)
  (with-slots (font-map printer-stream draw-p) stream 
    (let* ((styledesc (parse-text-style text-style))
	   (al (length font-map))
	   (fcs
	     (do ((i 0 (1+ i)))
		 ((>= i al)
		  (error "Font map overflow for ~S" stream))
	       (let ((fcs (aref font-map i)))
		 (when (null fcs)
		   (setq fcs (make-new-fcs styledesc i))
		   (setf (aref font-map i) fcs)
		   (return fcs))
		 (when (eq styledesc (psfck-style-descriptor fcs))
		   (return fcs))))))
      (when (and fcs 
		 draw-p
		 (not (psfck-established fcs)))
	(format printer-stream "~D ~D /~A estfont~%"
	  (psfck-index fcs) (psfck-points fcs) (get-ps-fam-face-name fcs))
	(setf (psfck-established fcs) t))
      fcs)))


;; PostScript's "default user space" is measured in printers' points.
;; Should these force the stream to map the font and then get the
;; information from the FCS?

(defmethod text-style-width (text-style (medium postscript-implementation-mixin))
  ;; an 'M' is often square and of height approximating the point size of the font.
  ;; should probably consult real metrics.
  (text-style-size-in-points text-style medium))

(defmethod text-style-height ((text-style standard-text-style)
			      (medium postscript-implementation-mixin))
  (text-style-size-in-points text-style medium))

(defmethod text-style-ascent ((text-style standard-text-style)
			      (medium postscript-implementation-mixin))
  (* (text-style-height text-style medium) (- 1 *ps-magic-baseline-factor*)))

(defmethod text-style-descent ((text-style standard-text-style)
			       (medium postscript-implementation-mixin))
  (* (text-style-height text-style medium) *ps-magic-baseline-factor*))

;;;--- This can probably go away when we have standardized text styles.
(defmethod text-style-size-in-points ((text-style standard-text-style)
				      (medium postscript-implementation-mixin))
  (let* ((family (text-style-family text-style))
	 (size (text-style-size text-style))
	 (famdat (or (assoc family *postscript-font-translate-data*)
		     (error "Don't have PostScript support for family ~A." family)))
	 (points (if (numberp size)
		     size
		     (point-size-for-size-keyword size famdat))))
    points))

(defmethod text-style-fixed-width-p ((text-style standard-text-style)
				     (stream postscript-implementation-mixin))
  (let* ((family (text-style-family text-style))
	 (face (text-style-face text-style))
	 (psfam (or (second (assoc family *postscript-font-translate-data*))
		    (error "Don't have PostScript support for family ~A." family)))
	 (famdat (cdr (or (assoc psfam *ps-font-family-data* :test #'string-equal)
			  (error "No info for PostScript font family ~A?" psfam))))
	 (info (cdr (or (assoc face famdat)
			(error "No info for PostScript family ~A face ~A." psfam face))))
 	 (cname (first info)))
    (numberp cname)))


(defclass postscript-device (display-device)
    ;; 72 points per inch on PostScript devices
    ((device-units-per-inch :initform 72 :allocation :class)))

(defmethod standardize-text-style ((device postscript-device) character-set style)
  (declare (ignore character-set))
  (let ((size (text-style-size style)))
    (if (numberp size)
	style
      (let* ((family (text-style-family style))
	     (sizes (third (assoc family *postscript-font-translate-data*)))
	     (position (position size *psftd-keywords*))
	     (new-size (and position (nth position sizes))))
	(cond (new-size
	       (make-text-style family (text-style-face style) new-size))
	      ((eql family :stand-in-for-undefined-style)
	       (make-text-style family (text-style-face style) 10))
	      (t
	       (cerror "Use the undefined text style stand-in instead"
		       "This display device does not know how to map the logical text ~
                        style size ~S in ~S"
		       size style)
	       *undefined-text-style*))))))

;; Some people need to be able to specialize this
(defmethod postscript-device-prologue ((device postscript-device) printer-stream)
  (declare (ignore printer-stream)))

;; Some people need to be able to specialize this, too
(defmethod postscript-device-epilogue ((device postscript-device) printer-stream)
  (declare (ignore printer-stream)))


(defclass apple-laser-writer (postscript-device)
    ((x-resolution :initform 300 :allocation :class)	;pixels per inch
     (y-resolution :initform 300 :allocation :class)
     (page-indent :initform  0.5 :allocation :class)	;in inches
     (page-width  :initform  7.5 :allocation :class)
     (page-height :initform 10.5 :allocation :class)))

;;; allow a display device to do something appropriate for a line thickness in :normal units
(defgeneric normal-line-thickness (display-device thickness))
  
(defmethod normal-line-thickness ((postscript-device display-device) (thickness number))
  thickness)

(defmethod normal-line-thickness ((postscript-device apple-laser-writer) (thickness number))
  (if (= thickness 1)
      0
      (* 0.5 thickness (/ (slot-value postscript-device 'device-units-per-inch)
			  (slot-value postscript-device 'x-resolution)))))

(define-display-device *postscript-device* apple-laser-writer
  :font-for-undefined-style "Courier")

(defclass postscript-stream
	  (postscript-implementation-mixin
	   ;; Following classes' protocols are disjoint
	   graphics-output-recording
	   ;; A little wierd, but we need it so that the "viewport" stuff gets
	   ;; handled during REPLAY of multi-page output
	   #-Silica output-and-window-protocol-intermediary
	   output-and-recording-protocol-intermediary
	   output-recording-mixin
	   graphics-mixin
	   output-protocol-mixin)
     ()
  (:default-initargs :display-device-type *postscript-device*
		     :default-text-margin 1000))

(defun make-postscript-stream (stream)
  (make-instance 'postscript-stream :stream stream))

(defmethod close ((stream postscript-stream) &key abort)
  (unless abort
    (postscript-epilogue stream)))

(defmethod postscript-bounding-box-edges ((stream postscript-stream))
  (with-bounding-rectangle* (left top right bottom)
      (stream-output-history stream)
    (pixels-to-points left top right bottom)
    (values (floor left) (floor top)
	    (ceiling right) (ceiling bottom))))

(defmethod window-inside-width ((stream postscript-implementation-mixin))
  (with-slots (display-device-type) stream
    (/ (* (slot-value display-device-type 'page-width)
	  (slot-value display-device-type 'device-units-per-inch))
       *1-pixel=points*)))

(defmethod drawing-surface-to-viewport-coordinates
	   ((stream postscript-implementation-mixin) dsx dsy)
  (declare (type coordinate dsx dsy))
  (with-slots (viewport-x viewport-y) stream
    (declare (type coordinate vx vy))
    (values (- dsx viewport-x) (- dsy viewport-y))))

(defmethod stream-ensure-cursor-visible ((stream postscript-implementation-mixin)
					 &optional cx cy)
  (declare (ignore cx cy))
  nil)

(defmethod stream-move-for-line-height-change ((stream postscript-implementation-mixin)
					       movement old-height cursor-x cursor-y)
  (declare (ignore movement old-height cursor-x cursor-y)))

;; Replay some PostScript output, breaking it into multiple pages
(defmethod stream-replay ((stream postscript-implementation-mixin) &optional region)
  (with-slots (output-record record-p draw-p display-device-type 
	       printer-stream orientation multi-page viewport-x viewport-y) stream
    (when draw-p
      (when output-record
	(letf-globally ((record-p nil))
	  (if (or region (not multi-page))
	      (replay output-record stream region)
	      (with-bounding-rectangle* (left top right bottom) output-record
		(let* ((page-width
			 (floor (* (slot-value display-device-type 'page-width)
				   (slot-value display-device-type 'device-units-per-inch))
				*1-pixel=points*))
		       (page-height
			 (floor (* (slot-value display-device-type 'page-height)
				   (slot-value display-device-type 'device-units-per-inch))
				*1-pixel=points*))
		       (first-page t))
		  (setq viewport-x 0 viewport-y 0)
		  ;; Draw each chunk of output on its own page
		  (unwind-protect
		      (do ((y top (+ y page-height)))
			  ((> y bottom))
			(do ((x left (+ x page-width)))
			    ((> x right))
			  (if first-page
			      (setq first-page nil)
			      (format printer-stream "gsave new-page grestore~%"))
			  (let ((region (make-bounding-rectangle
					  x y (+ x page-width) (+ y page-height))))
			    (replay output-record stream region))
			  (incf viewport-x page-width))
			(setf viewport-x 0)
			(incf viewport-y page-height))
		    (setq viewport-x 0 viewport-y 0))))))))))
		

(defmacro with-output-to-postscript-stream ((stream-var file-stream &rest args) &body body)
  (declare (arglist (stream-var file-stream
		     &key (display-device *postscript-device*)
			  header-comments multi-page 
			  (orientation :portrait))
		    &body body))
  `(flet ((postscript-output-body (,stream-var) ,@body))
     (declare (dynamic-extent #'postscript-output-body))
     (invoke-with-output-to-postscript-stream ,file-stream #'postscript-output-body ,@args)))

;; This could really be WITH-OPEN-STREAM, but that isn't going to call CLIM:CLOSE.
;; Fixed in the CLOS stream system.
(defun invoke-with-output-to-postscript-stream (file-stream continuation
						&key (display-device *postscript-device*)
						     header-comments multi-page
						     (orientation :portrait))
  (let ((postscript-stream (make-instance 'postscript-stream
					  :stream file-stream
					  :display-device-type display-device
					  :header-comments header-comments
					  :orientation orientation
					  :multi-page multi-page))
	(abort-p t))
    (with-output-recording-options (postscript-stream :record t :draw nil)
      (unwind-protect
	  (multiple-value-prog1
	    (funcall continuation postscript-stream)
	    (postscript-prologue postscript-stream)
	    ;; Now do the output to the printer, breaking up the output into
	    ;; multiple pages if that was requested
	    (with-output-recording-options (postscript-stream :record nil :draw t)
	      (frame-replay *application-frame* postscript-stream))
	    (setq abort-p nil))
	(close postscript-stream :abort abort-p)))))
